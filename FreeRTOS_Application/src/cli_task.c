/*
 * cli_task.c
 *
 *  Created on: Mar 19, 2014
 *      Author: RMamone
 */

#include "cli_task.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include "FreeRTOS_CLI.h"
#include <string.h>
#include <stdio.h>

#include "cdc_vcom.h"

#define CLITASKSTACKSIZE	512 // Stack size in words
#define MAX_INPUT_LENGTH    50
#define MAX_OUTPUT_LENGTH   100
static const char* pcWelcomeMessage = "FreeRTOS command server.\r\nType \'help\' to view a list of registered commands.\r\n";
static const char* pcPrompt = ">";

static void CLITask(void *pvParameters)
{
	unsigned char cRxedChar;
	unsigned char cInputIndex = 0;
	portBASE_TYPE xMoreDataToFollow;
	/* The input and output buffers are declared static to keep them off the stack. */
	static int8_t pcOutputString[MAX_OUTPUT_LENGTH];
	static int8_t pcInputString[MAX_INPUT_LENGTH];
	SemaphoreHandle_t usb_uart_connected_sem = (SemaphoreHandle_t)pvParameters;

	/* Wait for user to open the USB serial port */
	xSemaphoreTake(usb_uart_connected_sem, portMAX_DELAY);

	/* Send a welcome message to the user knows they are connected. */
    printf(pcWelcomeMessage);
    printf(pcPrompt);

	while(1)
	{
		/* This implementation reads a single character at a time.  Wait in the
		Blocked state until a character is received. */
		cRxedChar = getchar();

		if(cRxedChar == '\r')
		{
			/* A newline character was received, so the input command string is
			complete and can be processed.  Transmit a line separator, just to
			make the output easier to read. */
			printf("\r\n");

			/* The command interpreter is called repeatedly until it returns
			pdFALSE.  See the "Implementing a command" documentation for an
			explanation of why this is. */
			do
			{
				/* Send the command string to the command interpreter.  Any
				output generated by the command interpreter will be placed in the pcOutputString buffer. */
				xMoreDataToFollow = FreeRTOS_CLIProcessCommand(pcInputString, pcOutputString, MAX_OUTPUT_LENGTH);

				/* Write the output generated by the command interpreter to the	console. */
				printf((const char*)pcOutputString);

			} while(xMoreDataToFollow != pdFALSE);

			/* All the strings generated by the input command have been sent.
			Processing of the command is complete.  Clear the input string ready
			to receive the next command. */
			cInputIndex = 0;
			memset(pcInputString, 0x00, MAX_INPUT_LENGTH);
			printf(pcPrompt);
		}
		else
		{
			/* The if() clause performs the processing after a newline character
			is received.  This else clause performs the processing if any other
			character is received. */

			/* Echo back typed character */
			putchar(cRxedChar);

			if(cRxedChar == '\b')
			{
				/* Backspace was pressed.  Erase the last character in the input
				buffer - if there are any. */
				if(cInputIndex > 0)
				{
					cInputIndex--;
					pcInputString[cInputIndex] = '\0';
				}
			}
			else
			{
				/* A character was entered.  It was not a new line, backspace
				or carriage return, so it is accepted as part of the input and
				placed into the input buffer.  When a \n is entered the complete
				string will be passed to the command interpreter. */
				if( cInputIndex < MAX_INPUT_LENGTH )
				{
					pcInputString[cInputIndex] = cRxedChar;
					cInputIndex++;
				}
			}
		}
	}
}

unsigned long CLITaskInit(SemaphoreHandle_t usb_uart_connected_sem)
{
    if(xTaskCreate(CLITask, (signed portCHAR *)"CLI", CLITASKSTACKSIZE, (void*)usb_uart_connected_sem, tskIDLE_PRIORITY + PRIORITY_CLI_TASK, NULL) != pdTRUE)
        return(1);
    return(0);
}
