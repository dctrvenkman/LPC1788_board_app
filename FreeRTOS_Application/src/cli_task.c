/*
 * cli_task.c
 *
 *  Created on: Mar 19, 2014
 *      Author: RMamone
 */

#include "cli_task.h"
#include <string.h>
#include <stdio.h>
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include "FreeRTOS_CLI.h"
#include "cliParser.h"
#include "cdc_vcom.h"

#define CLITASKSTACKSIZE	(2 * 1024) // Stack size in words
#define MAX_INPUT_LENGTH    (64)
#define MAX_OUTPUT_LENGTH   (512)
static const char* pcWelcomeMessage = "FreeRTOS command server.\r\nType \'help\' to view a list of registered commands.\r\n";
static const char* pcPrompt = ">";

static void CLITask(void *pvParameters)
{
	unsigned char cRxedChar;
	unsigned char cInputIndex = 0;
	portBASE_TYPE xMoreDataToFollow;

	/* The input and output buffers are declared static to keep them off the stack. */
	static char pcOutputString[MAX_OUTPUT_LENGTH];
	static char pcInputString[MAX_INPUT_LENGTH];

	SemaphoreHandle_t usb_connected_sem = vcom_get_connected_sem();

	/* Wait for user to open the USB serial port */
	xSemaphoreTake(usb_connected_sem, portMAX_DELAY);

#ifdef FREERTOS_CLI
	/* Send a welcome message to the user knows they are connected. */
    printf(pcWelcomeMessage);
    printf(pcPrompt);

	while(1)
	{
		/* This implementation reads a single character at a time.  Wait in the
		Blocked state until a character is received. */
		cRxedChar = getchar();

		if(cRxedChar == '\r')
		{
			/* A newline character was received, so the input command string is
			complete and can be processed.  Transmit a line separator, just to
			make the output easier to read. */
			printf("\r\n");

			/* The command interpreter is called repeatedly until it returns
			pdFALSE.  See the "Implementing a command" documentation for an
			explanation of why this is. */
			do
			{
				/* Send the command string to the command interpreter.  Any
				output generated by the command interpreter will be placed in the pcOutputString buffer. */
				xMoreDataToFollow = FreeRTOS_CLIProcessCommand(pcInputString, pcOutputString, MAX_OUTPUT_LENGTH);

				/* Write the output generated by the command interpreter to the	console. */
				printf((const char*)pcOutputString);

			} while(xMoreDataToFollow != pdFALSE);

			/* All the strings generated by the input command have been sent.
			Processing of the command is complete.  Clear the input string ready
			to receive the next command. */
			cInputIndex = 0;
			memset(pcInputString, 0x00, MAX_INPUT_LENGTH);
			printf(pcPrompt);
		}
		else
		{
			/* The if() clause performs the processing after a newline character
			is received.  This else clause performs the processing if any other
			character is received. */

			/* Echo back typed character */
			putchar(cRxedChar);

			if(cRxedChar == '\b')
			{
				/* Backspace was pressed.  Erase the last character in the input
				buffer - if there are any. */
				if(cInputIndex > 0)
				{
					cInputIndex--;
					pcInputString[cInputIndex] = '\0';
				}
			}
			else
			{
				/* A character was entered.  It was not a new line, backspace
				or carriage return, so it is accepted as part of the input and
				placed into the input buffer.  When a \n is entered the complete
				string will be passed to the command interpreter. */
				if( cInputIndex < MAX_INPUT_LENGTH )
				{
					pcInputString[cInputIndex] = cRxedChar;
					cInputIndex++;
				}
			}
		}
	}
#else
	cliInit();
	cliRunLoop();
#endif
}

unsigned long CLITaskInit(void)
{
    if(xTaskCreate(CLITask, "CLI", CLITASKSTACKSIZE, 0, tskIDLE_PRIORITY + PRIORITY_CLI_TASK, NULL) != pdTRUE)
        return(1);
    return(0);
}
